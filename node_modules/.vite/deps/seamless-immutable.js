import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/seamless-immutable/seamless-immutable.development.js
var require_seamless_immutable_development = __commonJS({
  "node_modules/seamless-immutable/seamless-immutable.development.js"(exports, module) {
    (function() {
      "use strict";
      function immutableInit(config) {
        var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element");
        var REACT_ELEMENT_TYPE_FALLBACK = 60103;
        var globalConfig = {
          use_static: false
        };
        if (isObject(config)) {
          if (config.use_static !== void 0) {
            globalConfig.use_static = Boolean(config.use_static);
          }
        }
        function isObject(data) {
          return typeof data === "object" && !Array.isArray(data) && data !== null;
        }
        function instantiateEmptyObject(obj) {
          var prototype = Object.getPrototypeOf(obj);
          if (!prototype) {
            return {};
          } else {
            return Object.create(prototype);
          }
        }
        function addPropertyTo(target, methodName, value) {
          Object.defineProperty(target, methodName, {
            enumerable: false,
            configurable: false,
            writable: false,
            value
          });
        }
        function banProperty(target, methodName) {
          addPropertyTo(target, methodName, function() {
            throw new ImmutableError("The " + methodName + " method cannot be invoked on an Immutable data structure.");
          });
        }
        var immutabilityTag = "__immutable_invariants_hold";
        function addImmutabilityTag(target) {
          addPropertyTo(target, immutabilityTag, true);
        }
        function isImmutable(target) {
          if (typeof target === "object") {
            return target === null || Boolean(
              Object.getOwnPropertyDescriptor(target, immutabilityTag)
            );
          } else {
            return true;
          }
        }
        function isEqual(a, b) {
          return a === b || a !== a && b !== b;
        }
        function isMergableObject(target) {
          return target !== null && typeof target === "object" && !Array.isArray(target) && !(target instanceof Date);
        }
        var mutatingObjectMethods = [
          "setPrototypeOf"
        ];
        var nonMutatingObjectMethods = [
          "keys"
        ];
        var mutatingArrayMethods = mutatingObjectMethods.concat([
          "push",
          "pop",
          "sort",
          "splice",
          "shift",
          "unshift",
          "reverse"
        ]);
        var nonMutatingArrayMethods = nonMutatingObjectMethods.concat([
          "map",
          "filter",
          "slice",
          "concat",
          "reduce",
          "reduceRight"
        ]);
        var mutatingDateMethods = mutatingObjectMethods.concat([
          "setDate",
          "setFullYear",
          "setHours",
          "setMilliseconds",
          "setMinutes",
          "setMonth",
          "setSeconds",
          "setTime",
          "setUTCDate",
          "setUTCFullYear",
          "setUTCHours",
          "setUTCMilliseconds",
          "setUTCMinutes",
          "setUTCMonth",
          "setUTCSeconds",
          "setYear"
        ]);
        function ImmutableError(message) {
          this.name = "MyError";
          this.message = message;
          this.stack = new Error().stack;
        }
        ImmutableError.prototype = new Error();
        ImmutableError.prototype.constructor = Error;
        function makeImmutable(obj, bannedMethods) {
          addImmutabilityTag(obj);
          if (true) {
            for (var index in bannedMethods) {
              if (bannedMethods.hasOwnProperty(index)) {
                banProperty(obj, bannedMethods[index]);
              }
            }
            Object.freeze(obj);
          }
          return obj;
        }
        function makeMethodReturnImmutable(obj, methodName) {
          var currentMethod = obj[methodName];
          addPropertyTo(obj, methodName, function() {
            return Immutable2(currentMethod.apply(obj, arguments));
          });
        }
        function arraySet(idx, value, config2) {
          var deep = config2 && config2.deep;
          if (idx in this) {
            if (deep && this[idx] !== value && isMergableObject(value) && isMergableObject(this[idx])) {
              value = Immutable2.merge(this[idx], value, { deep: true, mode: "replace" });
            }
            if (isEqual(this[idx], value)) {
              return this;
            }
          }
          var mutable = asMutableArray.call(this);
          mutable[idx] = Immutable2(value);
          return makeImmutableArray(mutable);
        }
        var immutableEmptyArray = Immutable2([]);
        function arraySetIn(pth, value, config2) {
          var head = pth[0];
          if (pth.length === 1) {
            return arraySet.call(this, head, value, config2);
          } else {
            var tail = pth.slice(1);
            var thisHead = this[head];
            var newValue;
            if (typeof thisHead === "object" && thisHead !== null) {
              newValue = Immutable2.setIn(thisHead, tail, value);
            } else {
              var nextHead = tail[0];
              if (nextHead !== "" && isFinite(nextHead)) {
                newValue = arraySetIn.call(immutableEmptyArray, tail, value);
              } else {
                newValue = objectSetIn.call(immutableEmptyObject, tail, value);
              }
            }
            if (head in this && thisHead === newValue) {
              return this;
            }
            var mutable = asMutableArray.call(this);
            mutable[head] = newValue;
            return makeImmutableArray(mutable);
          }
        }
        function makeImmutableArray(array) {
          for (var index in nonMutatingArrayMethods) {
            if (nonMutatingArrayMethods.hasOwnProperty(index)) {
              var methodName = nonMutatingArrayMethods[index];
              makeMethodReturnImmutable(array, methodName);
            }
          }
          if (!globalConfig.use_static) {
            addPropertyTo(array, "flatMap", flatMap);
            addPropertyTo(array, "asObject", asObject);
            addPropertyTo(array, "asMutable", asMutableArray);
            addPropertyTo(array, "set", arraySet);
            addPropertyTo(array, "setIn", arraySetIn);
            addPropertyTo(array, "update", update);
            addPropertyTo(array, "updateIn", updateIn);
            addPropertyTo(array, "getIn", getIn);
          }
          for (var i = 0, length = array.length; i < length; i++) {
            array[i] = Immutable2(array[i]);
          }
          return makeImmutable(array, mutatingArrayMethods);
        }
        function makeImmutableDate(date) {
          if (!globalConfig.use_static) {
            addPropertyTo(date, "asMutable", asMutableDate);
          }
          return makeImmutable(date, mutatingDateMethods);
        }
        function asMutableDate() {
          return new Date(this.getTime());
        }
        function flatMap(iterator) {
          if (arguments.length === 0) {
            return this;
          }
          var result = [], length = this.length, index;
          for (index = 0; index < length; index++) {
            var iteratorResult = iterator(this[index], index, this);
            if (Array.isArray(iteratorResult)) {
              result.push.apply(result, iteratorResult);
            } else {
              result.push(iteratorResult);
            }
          }
          return makeImmutableArray(result);
        }
        function without(remove) {
          if (typeof remove === "undefined" && arguments.length === 0) {
            return this;
          }
          if (typeof remove !== "function") {
            var keysToRemoveArray = Array.isArray(remove) ? remove.slice() : Array.prototype.slice.call(arguments);
            keysToRemoveArray.forEach(function(el, idx, arr) {
              if (typeof el === "number") {
                arr[idx] = el.toString();
              }
            });
            remove = function(val, key2) {
              return keysToRemoveArray.indexOf(key2) !== -1;
            };
          }
          var result = instantiateEmptyObject(this);
          for (var key in this) {
            if (this.hasOwnProperty(key) && remove(this[key], key) === false) {
              result[key] = this[key];
            }
          }
          return makeImmutableObject(result);
        }
        function asMutableArray(opts) {
          var result = [], i, length;
          if (opts && opts.deep) {
            for (i = 0, length = this.length; i < length; i++) {
              result.push(asDeepMutable(this[i]));
            }
          } else {
            for (i = 0, length = this.length; i < length; i++) {
              result.push(this[i]);
            }
          }
          return result;
        }
        function asObject(iterator) {
          if (typeof iterator !== "function") {
            iterator = function(value2) {
              return value2;
            };
          }
          var result = {}, length = this.length, index;
          for (index = 0; index < length; index++) {
            var pair = iterator(this[index], index, this), key = pair[0], value = pair[1];
            result[key] = value;
          }
          return makeImmutableObject(result);
        }
        function asDeepMutable(obj) {
          if (!obj || typeof obj !== "object" || !Object.getOwnPropertyDescriptor(obj, immutabilityTag) || obj instanceof Date) {
            return obj;
          }
          return Immutable2.asMutable(obj, { deep: true });
        }
        function quickCopy(src, dest) {
          for (var key in src) {
            if (Object.getOwnPropertyDescriptor(src, key)) {
              dest[key] = src[key];
            }
          }
          return dest;
        }
        function merge(other, config2) {
          if (arguments.length === 0) {
            return this;
          }
          if (other === null || typeof other !== "object") {
            throw new TypeError("Immutable#merge can only be invoked with objects or arrays, not " + JSON.stringify(other));
          }
          var receivedArray = Array.isArray(other), deep = config2 && config2.deep, mode = config2 && config2.mode || "merge", merger = config2 && config2.merger, result;
          function addToResult(currentObj, otherObj, key2) {
            var immutableValue = Immutable2(otherObj[key2]);
            var mergerResult = merger && merger(currentObj[key2], immutableValue, config2);
            var currentValue = currentObj[key2];
            if (result !== void 0 || mergerResult !== void 0 || !currentObj.hasOwnProperty(key2) || !isEqual(immutableValue, currentValue)) {
              var newValue;
              if (mergerResult !== void 0) {
                newValue = mergerResult;
              } else if (deep && isMergableObject(currentValue) && isMergableObject(immutableValue)) {
                newValue = Immutable2.merge(currentValue, immutableValue, config2);
              } else {
                newValue = immutableValue;
              }
              if (!isEqual(currentValue, newValue) || !currentObj.hasOwnProperty(key2)) {
                if (result === void 0) {
                  result = quickCopy(currentObj, instantiateEmptyObject(currentObj));
                }
                result[key2] = newValue;
              }
            }
          }
          function clearDroppedKeys(currentObj, otherObj) {
            for (var key2 in currentObj) {
              if (!otherObj.hasOwnProperty(key2)) {
                if (result === void 0) {
                  result = quickCopy(currentObj, instantiateEmptyObject(currentObj));
                }
                delete result[key2];
              }
            }
          }
          var key;
          if (!receivedArray) {
            for (key in other) {
              if (Object.getOwnPropertyDescriptor(other, key)) {
                addToResult(this, other, key);
              }
            }
            if (mode === "replace") {
              clearDroppedKeys(this, other);
            }
          } else {
            for (var index = 0, length = other.length; index < length; index++) {
              var otherFromArray = other[index];
              for (key in otherFromArray) {
                if (otherFromArray.hasOwnProperty(key)) {
                  addToResult(result !== void 0 ? result : this, otherFromArray, key);
                }
              }
            }
          }
          if (result === void 0) {
            return this;
          } else {
            return makeImmutableObject(result);
          }
        }
        function objectReplace(value, config2) {
          var deep = config2 && config2.deep;
          if (arguments.length === 0) {
            return this;
          }
          if (value === null || typeof value !== "object") {
            throw new TypeError("Immutable#replace can only be invoked with objects or arrays, not " + JSON.stringify(value));
          }
          return Immutable2.merge(this, value, { deep, mode: "replace" });
        }
        var immutableEmptyObject = Immutable2({});
        function objectSetIn(path, value, config2) {
          if (!Array.isArray(path) || path.length === 0) {
            throw new TypeError('The first argument to Immutable#setIn must be an array containing at least one "key" string.');
          }
          var head = path[0];
          if (path.length === 1) {
            return objectSet.call(this, head, value, config2);
          }
          var tail = path.slice(1);
          var newValue;
          var thisHead = this[head];
          if (this.hasOwnProperty(head) && typeof thisHead === "object" && thisHead !== null) {
            newValue = Immutable2.setIn(thisHead, tail, value);
          } else {
            newValue = objectSetIn.call(immutableEmptyObject, tail, value);
          }
          if (this.hasOwnProperty(head) && thisHead === newValue) {
            return this;
          }
          var mutable = quickCopy(this, instantiateEmptyObject(this));
          mutable[head] = newValue;
          return makeImmutableObject(mutable);
        }
        function objectSet(property, value, config2) {
          var deep = config2 && config2.deep;
          if (this.hasOwnProperty(property)) {
            if (deep && this[property] !== value && isMergableObject(value) && isMergableObject(this[property])) {
              value = Immutable2.merge(this[property], value, { deep: true, mode: "replace" });
            }
            if (isEqual(this[property], value)) {
              return this;
            }
          }
          var mutable = quickCopy(this, instantiateEmptyObject(this));
          mutable[property] = Immutable2(value);
          return makeImmutableObject(mutable);
        }
        function update(property, updater) {
          var restArgs = Array.prototype.slice.call(arguments, 2);
          var initialVal = this[property];
          return Immutable2.set(this, property, updater.apply(initialVal, [initialVal].concat(restArgs)));
        }
        function getInPath(obj, path) {
          for (var i = 0, l = path.length; obj != null && i < l; i++) {
            obj = obj[path[i]];
          }
          return i && i == l ? obj : void 0;
        }
        function updateIn(path, updater) {
          var restArgs = Array.prototype.slice.call(arguments, 2);
          var initialVal = getInPath(this, path);
          return Immutable2.setIn(this, path, updater.apply(initialVal, [initialVal].concat(restArgs)));
        }
        function getIn(path, defaultValue) {
          var value = getInPath(this, path);
          return value === void 0 ? defaultValue : value;
        }
        function asMutableObject(opts) {
          var result = instantiateEmptyObject(this), key;
          if (opts && opts.deep) {
            for (key in this) {
              if (this.hasOwnProperty(key)) {
                result[key] = asDeepMutable(this[key]);
              }
            }
          } else {
            for (key in this) {
              if (this.hasOwnProperty(key)) {
                result[key] = this[key];
              }
            }
          }
          return result;
        }
        function instantiatePlainObject() {
          return {};
        }
        function makeImmutableObject(obj) {
          if (!globalConfig.use_static) {
            addPropertyTo(obj, "merge", merge);
            addPropertyTo(obj, "replace", objectReplace);
            addPropertyTo(obj, "without", without);
            addPropertyTo(obj, "asMutable", asMutableObject);
            addPropertyTo(obj, "set", objectSet);
            addPropertyTo(obj, "setIn", objectSetIn);
            addPropertyTo(obj, "update", update);
            addPropertyTo(obj, "updateIn", updateIn);
            addPropertyTo(obj, "getIn", getIn);
          }
          return makeImmutable(obj, mutatingObjectMethods);
        }
        function isReactElement(obj) {
          return typeof obj === "object" && obj !== null && (obj.$$typeof === REACT_ELEMENT_TYPE_FALLBACK || obj.$$typeof === REACT_ELEMENT_TYPE);
        }
        function isFileObject(obj) {
          return typeof File !== "undefined" && obj instanceof File;
        }
        function isBlobObject(obj) {
          return typeof Blob !== "undefined" && obj instanceof Blob;
        }
        function isPromise(obj) {
          return typeof obj === "object" && typeof obj.then === "function";
        }
        function isError(obj) {
          return obj instanceof Error;
        }
        function Immutable2(obj, options, stackRemaining) {
          if (isImmutable(obj) || isReactElement(obj) || isFileObject(obj) || isBlobObject(obj) || isError(obj)) {
            return obj;
          } else if (isPromise(obj)) {
            return obj.then(Immutable2);
          } else if (Array.isArray(obj)) {
            return makeImmutableArray(obj.slice());
          } else if (obj instanceof Date) {
            return makeImmutableDate(new Date(obj.getTime()));
          } else {
            var prototype = options && options.prototype;
            var instantiateEmptyObject2 = !prototype || prototype === Object.prototype ? instantiatePlainObject : function() {
              return Object.create(prototype);
            };
            var clone = instantiateEmptyObject2();
            if (true) {
              if (stackRemaining == null) {
                stackRemaining = 64;
              }
              if (stackRemaining <= 0) {
                throw new ImmutableError("Attempt to construct Immutable from a deeply nested object was detected. Have you tried to wrap an object with circular references (e.g. React element)? See https://github.com/rtfeldman/seamless-immutable/wiki/Deeply-nested-object-was-detected for details.");
              }
              stackRemaining -= 1;
            }
            for (var key in obj) {
              if (Object.getOwnPropertyDescriptor(obj, key)) {
                clone[key] = Immutable2(obj[key], void 0, stackRemaining);
              }
            }
            return makeImmutableObject(clone);
          }
        }
        function toStatic(fn) {
          function staticWrapper() {
            var args = [].slice.call(arguments);
            var self = args.shift();
            return fn.apply(self, args);
          }
          return staticWrapper;
        }
        function toStaticObjectOrArray(fnObject, fnArray) {
          function staticWrapper() {
            var args = [].slice.call(arguments);
            var self = args.shift();
            if (Array.isArray(self)) {
              return fnArray.apply(self, args);
            } else {
              return fnObject.apply(self, args);
            }
          }
          return staticWrapper;
        }
        function toStaticObjectOrDateOrArray(fnObject, fnArray, fnDate) {
          function staticWrapper() {
            var args = [].slice.call(arguments);
            var self = args.shift();
            if (Array.isArray(self)) {
              return fnArray.apply(self, args);
            } else if (self instanceof Date) {
              return fnDate.apply(self, args);
            } else {
              return fnObject.apply(self, args);
            }
          }
          return staticWrapper;
        }
        Immutable2.from = Immutable2;
        Immutable2.isImmutable = isImmutable;
        Immutable2.ImmutableError = ImmutableError;
        Immutable2.merge = toStatic(merge);
        Immutable2.replace = toStatic(objectReplace);
        Immutable2.without = toStatic(without);
        Immutable2.asMutable = toStaticObjectOrDateOrArray(asMutableObject, asMutableArray, asMutableDate);
        Immutable2.set = toStaticObjectOrArray(objectSet, arraySet);
        Immutable2.setIn = toStaticObjectOrArray(objectSetIn, arraySetIn);
        Immutable2.update = toStatic(update);
        Immutable2.updateIn = toStatic(updateIn);
        Immutable2.getIn = toStatic(getIn);
        Immutable2.flatMap = toStatic(flatMap);
        Immutable2.asObject = toStatic(asObject);
        if (!globalConfig.use_static) {
          Immutable2.static = immutableInit({
            use_static: true
          });
        }
        Object.freeze(Immutable2);
        return Immutable2;
      }
      var Immutable = immutableInit();
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Immutable;
        });
      } else if (typeof module === "object") {
        module.exports = Immutable;
      } else if (typeof exports === "object") {
        exports.Immutable = Immutable;
      } else if (typeof window === "object") {
        window.Immutable = Immutable;
      } else if (typeof global === "object") {
        global.Immutable = Immutable;
      }
    })();
  }
});
export default require_seamless_immutable_development();
//# sourceMappingURL=seamless-immutable.js.map
